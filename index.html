<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>t_cose: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">t_cose
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">t_cose Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> <img src="https://github.com/laurencelundblade/t_cose/blob/master/t-cose-logo.png?raw=true" alt="t_cose" class="inline"/></p>
<p><em>t_cose</em> implements enough of COSE to support <a href="https://tools.ietf.org/html/rfc8392">CBOR Web Token, RFC 8392</a> <br  />
 and <a href="https://tools.ietf.org/html/draft-ietf-rats-eat-01">Entity Attestation Token (EAT)</a>. This is the COSE_Sign1 part of <a href="https://tools.ietf.org/html/rfc9052">COSE, RFC 9052</a>.</p>
<p><b>Implemented in C with minimal dependency</b> – There are three main dependencies: 1) <a href="https://github.com/laurencelundblade/QCBOR">QCBOR</a>, 2) A cryptographic library for ECDSA and SHA-2, 3) C99, &lt;stdint.h&gt;, &lt;stddef.h&gt;, &lt;stdbool.h&gt; and &lt;string.h&gt;. It is highly portable to different HW, OS's and cryptographic libraries. Except for some minor configuration for the cryptographic library, no #ifdefs or compiler options need to be set for it to run correctly.</p>
<p><b>Crypto Library Integration Layer</b> – Works with different cryptographic libraries via a simple integration layer. The integration layer is kept small and simple, just enough for the use cases, so that integration is simpler. Integration layers for the OpenSSL and ARM Mbed TLS (PSA Cryptography API) cryptographic libraries are included.</p>
<p><b>Secure coding style</b> – Uses a construct called UsefulBuf / q_useful_buf as a discipline for safe coding and handling of binary data.</p>
<p><b>Small simple memory model</b> – Malloc is not needed. Besides the cryptographic library and payload buffer, about 600 bytes of heap/stack is needed for signing and 1500 bytes for verifying. The caller supplies the output buffer and context structures so the caller has control over memory usage making it useful for embedded implementations that have to run in small fixed memory.</p>
<h2><a class="anchor" id="autotoc_md0"></a>
Documentation</h2>
<p><a href="https://laurencelundblade.github.io/t_cose/">API documentation is here</a></p>
<h2><a class="anchor" id="autotoc_md1"></a>
Code Status</h2>
<p>As of March 2022, the code is in good working order and the public interface has been stable for over a year.</p>
<p>Integration with the <a href="https://www.openssl.org">OpenSSL</a> and <a href="https://github.com/ARMmbed/mbedtls">Arm Mbed TLS</a> cryptographic libraries is fully supported.</p>
<p>t_cose 1.0 only supports COSE Sign1, signing with one recipeint.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
t_cose 2.0</h2>
<p>As of August 2022, there are alpha releases of t_cose 2.0. It supports:</p><ul>
<li>COSE_Sign</li>
<li>Multiple signatures</li>
<li>COSE_MAC0</li>
<li>COSE_Encrypt and COSE_Encrypt0</li>
<li>Encryption with ECDH per RFC 9053</li>
</ul>
<p>See the dev branch and the releases.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Building and Dependencies</h2>
<p>Except for the crypto library set up, t_cose is very portable and should largely just work in any environment. It needs a few standard libraries and <a href="https://github.com/laurencelundblade/QCBOR">QCBOR</a> (which is also very portable). Hence most of this section is about crypto library set up.</p>
<h3><a class="anchor" id="autotoc_md4"></a>
QCBOR</h3>
<p>If QCBOR is installed in /usr/local, then the makefiles should find it. If not then QCBOR may need to be downloaded. The makefiles can be modified to reference it other than in /usr/local.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Supported Cryptographic Libraries</h3>
<p>Here's three crypto library configurations that are supported. Others can be added with relative ease.</p>
<h4><a class="anchor" id="autotoc_md6"></a>
Test Crypto – Makefile.test</h4>
<p>This configuration should work instantly on any device and is useful to do a large amount of testing with, but can't be put to full commercial use. What it lacks is integration with an ECDSA implementation so it can't produce real ECDSA signatures. It does however produce fake signatures called "short-circuit
signatures" that are very useful for testing. See header documentation for details on short-circuit sigs.</p>
<p>This configuration (and only this configuration) uses a bundled SHA-256 implementation (SHA-256 is simple and easy to bundle, ECDSA is not).</p>
<p>To build run: </p><pre class="fragment">make -f Makefile.test
</pre> <h4><a class="anchor" id="autotoc_md7"></a>
OpenSSL Crypto – Makefile.ossl</h4>
<p>This OpenSSL integration supports SHA-256, SHA-384 and SHA-512 with ECDSA, EdDSA, or RSAPSS to support the COSE algorithms ES256, ES384 and ES512, PS256, PS384 and PS512. It is a full and tested integration with OpenSSL crypto.</p>
<p>If OpenSSL is installed in /usr/local or as a standar library, you can probably just run make: </p><pre class="fragment">make -f Makefile.ossl
</pre><p> The specific things that Makefile.ossl does is:</p><ul>
<li>Links the crypto_adapters/t_cose_openssl_crypto.o into libt_cose.a</li>
<li>Links test/test/t_cose_make_openssl_test_key.o into the test binary</li>
<li><code>#define T_COSE_USE_OPENSSL_CRYPTO</code></li>
</ul>
<p>t_cose is regularly tested against OpenSSL 1.1.1 and 3.0.</p>
<p>The crypto adaptor for OpenSSL is about twice the size of that for Mbed TLS because the API doesn't line up well with the needs for COSE (OpenSSL is ASN.1/DER oriented). Memory allocation is performed inside OpenSSL and in the crypto adaptation layer. This makes the OpenSSL crypto library less suitable for embedded use.</p>
<p>No deprecated or to-be-deprecated APIs are used.</p>
<p>There are several different sets of APIs in OpenSSL that can be used to implement ECDSA and hashing. The ones chosen are the most official and well-supported, however others might suit particular uses cases better. An older t_cose used some to-be-deprecated APIs and is a more efficient than this one. It is unfortunate that these APIs (ECDSA_do_sign and ECDSA_do_verify) are slated for deprecation and there is no supported alternative to those that work only with DER-encoded signatures.</p>
<p>There are no known problems with the code and test coverage for the adaptor is good. Not every single memory allocation failure has test coverage, but the code should handle them all correctly.</p>
<h4><a class="anchor" id="autotoc_md8"></a>
PSA Crypto – Makefile.psa</h4>
<p>As of March 2022, t_cose works with the PSA 1.0 Crypto API as implemented by Mbed TLS 2.x and 3.x.</p>
<p>This integration supports SHA-256, SHA-384 and SHA-512 with ECDSA, EdDSA or RSAPSS to support the COSE algorithms ES256, ES384 and ES512, PS256, PS384 and PS512.</p>
<p>If Mbed TLS is installed in /usr/local, you can probably just run make: </p><pre class="fragment">make -f Makefile.psa
</pre><p> If this doesn't work or you have Mbed TLS elsewhere edit the makefile.</p>
<p>The specific things that Makefile.psa does is:</p><ul>
<li>Links the crypto_adapters/t_cose_psa_crypto.o into libt_cose.a</li>
<li>Links test/test/t_cose_make_psa_test_key.o into the test binary</li>
<li><code>#define T_COSE_USE_PSA_CRYPTO</code> <br  />
</li>
</ul>
<p>This crypto adapter is small and simple. The adapter allocates no memory and as far as I know it internally allocates no memory. It is a good choice for embedded use.</p>
<p>It makes use of the 1.0 version of the PSA cryptographic API. No deprecated or to-be-deprecated functions are called (an older t_cose used some to be deprecated APIs).</p>
<p>It is regularly tested against the latest version 2 and version 3 of Mbed TLS, an implementation of the PSA crypto API.</p>
<p>Confidence in the adaptor code is high and reasonably well tested because it is simple.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
General Crypto Library Strategy</h3>
<p>The functions that t_cose needs from the crypto library are all defined in src/t_cose_crypto.h. This is a porting or adaption layer. There are no #ifdefs in the main t_cose code for different crypto libraries. When it needs a crypto function it just calls the interface defined in t_cose_crypto.h.</p>
<p>When integrating t_cose with a new cryptographic library, what is necessary is to write some code, an "adaptor", that implements t_cose_crypto.h using the new target cryptographic library. This can be done without changes to any t_cose code for many cryptographic libraries. See the interface documentation in t_cose_crypto.h for what needs to be implemented.</p>
<p>That said, there is one case where t_cose source code needs to be modified. This is for hash algorithm implementations that are linked into and run inline with t_cose and that have a context structure. In this case t_cose_crypto.h should be modified to use that context structure. Use the OpenSSL configuration as an example.</p>
<p>To complete the set up for a new cryptographic library and test it, a new test adaptation file is also needed. This file makes public key pairs of the correct type for use with testing. This file is usually named test/t_cose_make_xxxx_test_key.c and is linked in with the test app. The keys it makes are passed through t_cose untouched, through the t_cose_crypto.h interface into the underlying crypto.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Memory Usage</h2>
<h3><a class="anchor" id="autotoc_md11"></a>
Code</h3>
<p>Here are code sizes on 64-bit x86 optimized for size </p><pre class="fragment"> |                           | smallest | largest |  
 |---------------------------|----------|---------|
 | signing only              |     1500 |    2300 |
 | verification only         |     2500 |    3300 |
 | common to sign and verify |     (500)|    (800)|
 | combined                  |     3500 |    4800 |
</pre><p> Things that make the code smaller:</p><ul>
<li>PSA / Mbed crypto takes less code to interface with than OpenSSL</li>
<li>gcc is usually smaller than llvm because stack guards are off by default</li>
<li>Use only 256-bit crypto with the T_COSE_DISABLE_ESXXX options</li>
<li>Disable short-circut sig debug faclity T_COSE_DISABLE_SHORT_CIRCUIT_SIGN</li>
<li>Disable the content type header T_COSE_DISABLE_CONTENT_TYPE</li>
</ul>
<h4><a class="anchor" id="autotoc_md12"></a>
Change in code size with spiffy decode</h4>
<p>The encode size is as before.</p>
<p>Compared to the previous t_cose, the code size for decoding/verifying is reduced by about 600 bytes. However, spiffy decode functions in QCBOR are now required and they are about 2KB, so there is a net size increase of 1.4KB. But use of spiffy decode will also make other parts of the overall SW stack smaller, perhaps by a lot, so this will likely break even. For example, EAT or CWT decoding will be reduced a lot through use of spiffy decode. Basically, the more CBOR maps a SW stack has to handle, the more saving there will be from spiffy decode.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Heap and stack</h3>
<p>Malloc is not used.</p>
<p>Stack usage is variable depending on the key and hash size and the stack usage by the cryptographic library that performs the hash and public key crypto functions. The maximum requirement is roughly 2KB. This is an estimate from examining the code, not an actual measurement.</p>
<p>Since the keys, hash outputs and signatures are stored on the stack, the stronger the security, the more stack is used. By default up to 512 bit EC is enabled. Disable 512 and 384 bit EC to reduce stack usage by about 100 bytes.</p>
<p>Different cryptographic libraries may have very different stack usage characteristics. For example if one use malloc rather than the stack, it will (hopefully) use less stack. The guess estimate range of usage by the cryptographic library is between 64 and 1024 bytes of stack.</p>
<p>Aside from the cryptographic library, the base stack use by t_cose is 500 bytes for signing and 1500 bytes for verification. With a large cryptographic library, the total is about 1500 bytes for signing and 2000 bytes for verification (for verification, the crypto library stack re uses stack used to decode header parameters so the increment isn't so large).</p>
<p>The design is such that only one copy of the output, the COSE_Sign1, need be in memory. It makes use of special features in QCBOR that allows contstuction of the output including the payload, using just the single output buffer to accomplish this.</p>
<p>A buffer to hold the signed COSE result must be passed in. It must be about 100 bytes larger than the combined size of the payload and key id for ECDSA 256. It can be allocated as the caller wishes.</p>
<h3><a class="anchor" id="autotoc_md14"></a>
Crypto library memory usage</h3>
<p>In addition to the above memory usage, the crypto library will use some stack and/or heap memory. This will vary quite a bit by crypto library. Some may use malloc. Some may not.</p>
<p>The OpenSSL library does use malloc, even with ECDSA. Another implementation of ECDSA might not use malloc, as the keys are small enough.</p>
<h3><a class="anchor" id="autotoc_md15"></a>
Mixed code style</h3>
<p>QCBOR uses camelCase and t_cose follows <a href="https://git.trustedfirmware.org/TF-M/trusted-firmware-m.git/tree/docs/contributing/coding_guide.rst">Arm's coding guidelines</a> resulting in code with mixed styles. For better or worse, an Arm-style version of UsefulBuf is created and used and so there is a duplicate of UsefulBuf. The two are identical. They just have different names.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Limitations</h2>
<ul>
<li>Most inputs and outputs must be in a continguous buffer. One exception to this is that CBOR payloads being signed can be constructed piecemeal into the output buffer and signed without using a separate buffer.</li>
<li>Doesn't handle COSE string algorithm IDs. Only COSE integer algorithm IDs are handled. Thus far no string algorithm IDs have been assigned by IANA.</li>
<li>No way to add custom headers when creating signed messages or process them during verification.</li>
<li>Does not handle CBOR indefinite length strings (indefinite length maps and arrays are handled).</li>
<li>Counter signatures are not supported.</li>
</ul>
<h2><a class="anchor" id="autotoc_md17"></a>
Credit</h2>
<ul>
<li>Paul Liétar for RSA PSS (PS256..PS512) and EdDSA</li>
<li>Maik Riechert for cmake, CI and other.</li>
<li>Ken Takayama for the bulk of the detached content implementation.</li>
<li>Tamas Ban for lots code review comments, design ideas and porting to ARM PSA.</li>
<li>Rob Coombs, Shebu Varghese Kuriakose and other ARM folks for sponsorship.</li>
<li>Michael Eckel for makefile fixes.</li>
</ul>
<h2><a class="anchor" id="autotoc_md18"></a>
Copyright and License</h2>
<p>t_cose is available under the 3-Clause BSD License. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
